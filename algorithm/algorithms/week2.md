# 状态压缩 & 双向搜索

这二者都是思想大于实现, 实现难度较低, 但是需要时刻记住有这么一回事.

# 对顶堆

[295. 数据流的中位数 - 力扣（LeetCode）](https://leetcode.cn/problems/find-median-from-data-stream/description/)

## 解答思路

一个堆可以实时保存一个序列中最大的 k 个值或最小的 k 个值, 且堆顶为第 k 大或第 k 小.

代码见`src/T295.cpp`

# 递归式二分查找

这里主要是给线段树开一个引子.

给定一个单调不减的序列, 包含 n 个数字. 给定 x, 求序列中第一个大于等于 x 的数字.

在写二分查找时, 不熟练的话, 很可能无法逻辑清晰地写出代码, 有时需要进行漫长的调试. 但是如果将逻辑交给递归, 则会简单很多.

代码见`src/BinarySearch.cpp`

# 线段树

线段树的核心思想是递归, 或说是分治. 如果一个区间问题可以分解为两个自区间的问题, 则可以考虑使用线段树.

线段树是一种非常强大的数据结构, 使用范围十分灵活, 时空开销非常均衡, 很多情况下可以降低思维难度.

线段树的核心功能是支持 logn 的单点查询, 区间查询, 单点修改, 区间修改.

## 数组形式

我们将每一个节点都存储在一个数组中, 根节点为 1.

x 的左子节点是 `(x << 1)`, 右子节点是 `(x << 1 | 1)`.

若 x 代表区间 `[l, r]`, 令 `mid = l + r >> 1`, 则左子区间为 `[l, mid]`, 右子区间为 `[mid + 1, r]`.

关于空间复杂度, 若区间长度为 n, 存储线段树节点的数组, 最安全的大小是 `4n`, 因为实际上叶子节点有 n 个, 每往上一级节点数目减半, 因此有

$$
sum = n + \frac{n}{2} + \frac{n}{2^2} + ... + 1 = 2n
$$

但事实上, 如果开的节点刚好为 2n, 是不安全的. 因为我们并不能保证所有的叶子节点落在同一层, 有时候可能有零散的叶子节点点落在了更深的一层, 因此至少需要开 4n 的大小.(胡说八道ing...)

## 动态开点

我们使用一个结构体记录线段树的各种信息, 包括左子节点指针, 右子节点指针, 以及求解实际问题所需要的各种值.

在实际操作时, 我们先 new 一个根指针, 作为线段树操作的入口.

在读操作时, 若当前节点指针为 null, 则直接返回无解. 若当前到达边界条件, 则返回结果.

在写操作时, 首先我们保证根节点肯定是存在的. 在递归遍历左右子节点之前, 我们需要判断一下子节点是否存在, 若不存在, 则需要 new 一个. 

动态开点保证了我们整个内存中的节点是都是有需要的节点, 当区间定义域很大, 但真正涉及到的区间却很少时, 每个区间就至多新开 logn 个节点.

因此在使用动态开点时, 我们实际能够解决的定义域是扩大了的. 数组形式只能处理有限个数字, 如 2e5, 1e6 之类, 一般区间 `[l, r]` 对应的就是原序列 `[l, r]`. 但使用动态开点, 我们完全可以使用 `[l, r]` 直接代表值域 `[l, r]`, 上界可以到 1e9 或更大, **但是需要注意 `(l + r >> 1)` 爆 int 的情况!!!**

